<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Go 1.18 泛型全面讲解：一篇讲清泛型的全部 - 晚风的博客</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="wanfeng"><meta name=description content="序 2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着Go1.18发布了。 可是因为Go对泛型的支持时间跨度太大，有非常多的以“泛"><meta name=keywords content="blog,java,java web"><meta name=generator content="Hugo 0.96.0"><link rel=canonical href=https://studyboot.com/post/go-1-8-generics/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.fa4b2b9f31b5c6d0b683db81157a9226e17b06e61911791ab547242a4a0556f2.css integrity="sha256-+ksrnzG1xtC2g9uBFXqSJuF7BuYZEXkatUckKkoFVvI=" media=screen crossorigin=anonymous><meta property="og:title" content="Go 1.18 泛型全面讲解：一篇讲清泛型的全部"><meta property="og:description" content="序 2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着Go1.18发布了。 可是因为Go对泛型的支持时间跨度太大，有非常多的以“泛"><meta property="og:type" content="article"><meta property="og:url" content="https://studyboot.com/post/go-1-8-generics/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-14T00:00:00+00:00"><meta property="article:modified_time" content="2022-04-14T00:00:00+00:00"><meta itemprop=name content="Go 1.18 泛型全面讲解：一篇讲清泛型的全部"><meta itemprop=description content="序 2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着Go1.18发布了。 可是因为Go对泛型的支持时间跨度太大，有非常多的以“泛"><meta itemprop=datePublished content="2022-04-14T00:00:00+00:00"><meta itemprop=dateModified content="2022-04-14T00:00:00+00:00"><meta itemprop=wordCount content="14547"><meta itemprop=keywords content="go,golang,templates,themes,development,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 1.18 泛型全面讲解：一篇讲清泛型的全部"><meta name=twitter:description content="序 2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着Go1.18发布了。 可是因为Go对泛型的支持时间跨度太大，有非常多的以“泛"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>晚风的博客</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=https://studyboot.com/>主页</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://studyboot.com/post/>全部文章</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://studyboot.com/tags/>标签</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://studyboot.com/categories/>分类</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://studyboot.com/about/>关于</a></li><li class=mobile-menu-item><div class=mobile-menu-parent><span class=mobile-submenu-open></span>
<a href=https://studyboot.com/>docs</a></div><ul class=mobile-submenu-list><li><a href=https://studyboot.com/post/image-preview/>Image Preview</a></li><li><a href=https://studyboot.com/post/syntax-highlighting/>Syntax Highlighting</a></li><li><a href=https://studyboot.com/post/math-preview/>Math Preview</a></li></ul></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class="header container"><div class=logo-wrapper><a href=/ class=logo>晚风的博客</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://studyboot.com/>主页</a></li><li class=menu-item><a class=menu-item-link href=https://studyboot.com/post/>全部文章</a></li><li class=menu-item><a class=menu-item-link href=https://studyboot.com/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=https://studyboot.com/categories/>分类</a></li><li class=menu-item><a class=menu-item-link href=https://studyboot.com/about/>关于</a></li><li class=menu-item><a class="menu-item-link menu-parent" href=https://studyboot.com/>docs</a><ul class=submenu><li><a href=https://studyboot.com/post/image-preview/>Image Preview</a></li><li><a href=https://studyboot.com/post/syntax-highlighting/>Syntax Highlighting</a></li><li><a href=https://studyboot.com/post/math-preview/>Math Preview</a></li></ul></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight"><div class=content-wrapper><div id=content class="content container"><article class="post bg-white"><header class=post-header><h1 class=post-title>Go 1.18 泛型全面讲解：一篇讲清泛型的全部</h1><div class=post-meta><time datetime=2022-04-14 class=post-time>2022-04-14</time><div class=post-category><a href=https://studyboot.com/categories/development/>Development</a>
<a href=https://studyboot.com/categories/golang/>golang</a>
<a href=https://studyboot.com/categories/index/>index</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#序>序</a></li><li><a href=#1-一切从函数的形参和实参说起>1. 一切从函数的形参和实参说起</a></li><li><a href=#2-go的泛型>2. Go的泛型</a></li><li><a href=#3-类型形参类型实参类型约束和泛型类型>3. 类型形参、类型实参、类型约束和泛型类型</a><ul><li><a href=#31-其他的泛型类型>3.1 其他的泛型类型</a></li><li><a href=#32-类型形参的互相套用>3.2 类型形参的互相套用</a></li><li><a href=#33-几种语法错误>3.3 几种语法错误</a></li><li><a href=#34-特殊的泛型类型>3.4 特殊的泛型类型</a></li><li><a href=#35-泛型类型的套娃>3.5 泛型类型的套娃</a></li><li><a href=#36-泛型约束的两种选择>3.6 泛型约束的两种选择</a></li><li><a href=#37-匿名结构体不支持泛型>3.7 匿名结构体不支持泛型</a></li></ul></li><li><a href=#4-泛型receiver>4. 泛型receiver</a><ul><li><a href=#41-基于泛型的队列>4.1 基于泛型的队列</a></li><li><a href=#42-动态判断变量的类型>4.2 动态判断变量的类型</a></li></ul></li><li><a href=#5-泛型函数>5. 泛型函数</a><ul><li><a href=#51-匿名函数不支持泛型>5.1 匿名函数不支持泛型</a></li><li><a href=#52-既然支持泛型函数那么泛型方法呢>5.2 既然支持泛型函数，那么泛型方法呢？</a></li></ul></li><li><a href=#前半小结>前半小结</a></li><li><a href=#6-变得复杂的接口>6. 变得复杂的接口</a><ul><li><a href=#61---指定底层类型>6.1 <code>~</code> : 指定底层类型</a></li><li><a href=#62-从方法集method-set到类型集type-set>6.2 从方法集(Method set)到类型集(Type set)</a></li><li><a href=#63-接口两种类型>6.3 接口两种类型</a></li><li><a href=#64-泛型接口>6.4 泛型接口</a></li><li><a href=#65-接口定义的种种限制规则>6.5 接口定义的种种限制规则</a></li></ul></li><li><a href=#7-总结>7. 总结</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></div><div class=post-content><h2 id=序>序</h2><p>2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着Go1.18发布了。</p><p>可是因为Go对泛型的支持时间跨度太大，有非常多的以“泛型”为关键字的文章都是在介绍Go1.18之前的旧泛型提案或者设计。而很多设计最终在Go1.18中被废弃或发生了更改。并且很多介绍Go1.18泛型的文章(包括官方的)都过于简单，并没对Go的泛型做完整的介绍，也没让大家意识到这次Go引入泛型给语言增加了多少复杂度（当然也可能单纯是我没搜到更好的文章）</p><p>出于这些原因，我决定参考 <strong><a href="https://link.segmentfault.com/?enc=ZZG5fjFHE5hLZnE4NyJYkQ%3D%3D.Xi%2FmiNGp1Mmp4iGbA2pmAML60fH99AHRR2B%2F7Lr6KAo%3D">The Go Programming Language Specification</a></strong> ，写一篇比较完整系统介绍Go1.18 泛型的文章。这篇文章可能是目前介绍Go泛型比较全面的文章之一了</p><p>💡 本文力求能让未接触过泛型编程的人也能较好理解Go的泛型，所以行文可能略显啰嗦。但是请相信我，看完这篇文章你能获得对Go泛型非常全面的了解</p><h2 id=1-一切从函数的形参和实参说起>1. 一切从函数的形参和实参说起</h2><p>假设我们有个计算两数之和的函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>a</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个函数很简单，但是它有个问题——无法计算int类型之外的和。如果我们想计算浮点或者字符串的和该怎么办？解决办法之一就是像下面这样为不同类型定义不同的函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>AddFloat32</span><span class=p>(</span><span class=nx>a</span> <span class=kt>float32</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>float32</span><span class=p>)</span> <span class=kt>float32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>AddString</span><span class=p>(</span><span class=nx>a</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可是除此之外还有没有更好的方法？答案是有的，我们可以来回顾下函数的 <strong>形参(parameter)</strong> 和 <strong>实参(argument)</strong> 这一基本概念：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>a</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=c1>// 变量a,b是函数的形参   &#34;a int, b int&#34; 这一串被称为形参列表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>Add</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span><span class=mi>200</span><span class=p>)</span> <span class=c1>// 调用函数时，传入的100和200是实参
</span></span></span></code></pre></td></tr></table></div></div><p>我们知道，函数的 <strong>形参(parameter)</strong> 只是类似占位符的东西并没有具体的值，只有我们调用函数传入<strong>实参(argument)</strong> 之后才有具体的值。</p><p>如果我们将函数形参实参这个概念推广一下，给变量的类型引入和函数形参实参类似的概念的话，问题就迎刃而解：在这里我们将其称之为 <strong>类型形参(type parameter)</strong> 和 <strong>类型实参(type argumetn)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 假设 T 是类型形参，在定义函数时它的类型是不确定的，类似占位符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>a</span> <span class=nx>T</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=nx>T</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在上面这段伪代码中， T 被称为 <strong>类型形参</strong>， 它不是具体的类型，在定义函数时类型并不确定。因为 T 的类型并不确定，所以我们可以像函数的形参那样，在调用函数的时候再传入具体的类型。这样我们不就能一个函数同时支持多个不同的类型了吗？</p><p>就像下面的伪代码一样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [T=int]中的 int 是类型实参，代表着函数Add()定义中的类型形参 T 全都被 int 替换
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>Add</span><span class=p>[</span><span class=nx>T</span><span class=p>=</span><span class=kt>int</span><span class=p>](</span><span class=mi>100</span><span class=p>,</span> <span class=mi>200</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=c1>// 传入类型实参int后，Add()函数的定义可近似看成下面这样：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Add</span><span class=p>(</span> <span class=nx>a</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 另一个例子，[T=string]中的string是类型实参
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>Add</span><span class=p>[</span><span class=nx>T</span><span class=p>=</span><span class=kt>string</span><span class=p>](</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=s>&#34;World&#34;</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=c1>// 类型实参string传入后，Add()函数的开一可以近似是为下面这样
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Add</span><span class=p>(</span> <span class=nx>a</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过上面这样引入了 <strong>类型形参</strong> 和 <strong>类型实参</strong> 后，我们就让一个函数获得了处理多个不同类型的能力，我们称为 <strong>泛型编程</strong>。</p><p>可能你会已奇怪，这种类型动态处理类型的功能，我通过Go的接口和反射似乎也能实现？泛型能比接口+反射更加轻松高性能地实现很多功能，但本身也有很多限制。至于该选择泛型还是接口+反射，记住下面这样的一条规则：</p><blockquote><p>如果你经常要分别为不同的类型写完全同样逻辑的代码，那么使用泛型将是最合适的选择</p></blockquote><h2 id=2-go的泛型>2. Go的泛型</h2><p>通过上面的内容，我们实际上已经对Go的泛型编程有了最初步也是最重要的认识—— 类型形参 和 类型实参。而Go1.18也是通过这种方式实现的泛型，但是单纯的形参实参是远远不能实现泛型编程的，所以Go还引入了非常多全新的概念：</p><ul><li>类型形参 (Type parameter)</li><li>类型实参(Type argument)</li><li>类型形参列表( Type parameter list)</li><li>类型约束(Type constraint)</li><li>实例化(Instantiations)</li><li>泛型类型(Generic type)</li><li>泛型接收器(Generic receiver)</li><li>泛型函数(Generic function)</li></ul><p>等等等等。</p><p>啊，实在概念太多了头晕？没事请跟着我慢慢来，首先从 <strong>泛型类型(generic type)</strong> 讲起</p><h2 id=3-类型形参类型实参类型约束和泛型类型>3. 类型形参、类型实参、类型约束和泛型类型</h2><p>观察下面这个简单的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>IntSlice</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=nx>IntSlice</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span> <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>b</span> <span class=nx>IntSlice</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>float32</span><span class=p>{</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>}</span> <span class=c1>// ✗ 错误，因为IntSlice的底层类型是[]int，浮点类型的切片无法赋值
</span></span></span></code></pre></td></tr></table></div></div><p>这里定义了一个新的类型 <code>IntSlice</code> ，它的底层类型是 <code>[]int</code> ，理所当然只有int类型的切片能赋值给 <code>IntSlice</code> 类型的变量。</p><p>接下来如果我们想要定个可以容纳 <code>float32</code> 或 <code>string</code> 等其他类型的切片的话该怎么办？很简单，再定义对应的类型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>StringSlice</span> <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Float32Slie</span> <span class=p>[]</span><span class=kt>float32</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Float64Slice</span> <span class=p>[]</span><span class=kt>float64</span>
</span></span></code></pre></td></tr></table></div></div><p>但是这样做的问题显而易见，它们结构都是一样的只是成员类型不同就需要重新定义这么多新类型。那么有没有一个办法能只定义一个类型就能代表上面这所有的类型呢？答案是可以的，这时候就需要用到泛型了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span><span class=p>|</span><span class=kt>float32</span><span class=p>|</span><span class=kt>float64</span> <span class=p>]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span></code></pre></td></tr></table></div></div><p>不同于一般的类型定义，这里类型名称 <code>Slice</code> 后带了中括号，对各个部分做一个解说就是：</p><ul><li><code>T</code> 就是上面介绍过的<strong>类型形参(Type parameter)</strong>，在定义Slice类型的时候T代表的具体类型并不确定类似一个占位符</li><li><code>int|float32</code> 这部分被称为<strong>类型约束(Type constraint)</strong>，中间的 <code>|</code> 的意思是告诉编译器，类型形参T可以接收 int 或 float32 这两种类型</li><li>中括号里的 <code>T int|float32</code> 这一串因为定义了所有的类型形参(在这个例子里只有一个类型形参），所以我们称其为 <strong>类型形参列表(type parameter list)</strong></li><li>这里新定义的类型名称叫 <code>Slice[T]</code></li></ul><p>很明显，这种类型定义的方式中带了类型形参，和普通的类型定义非常不一样，所以我们将这种</p><blockquote><p>类型定义中带 *<strong>类型形参*</strong> 的类型，称之为 <strong>泛型类型(Generic type)</strong></p></blockquote><p>泛型类型不能直接拿来使用，必须传入<strong>类型实参(Type argument)</strong> 将其确定为具体的类型之后才可使用。而传入类型实参确定称具体的类型，这一操作被称为 <strong>实例化(Instantiations)</strong> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ✗ 错误。Slice[T]是泛型类型，不可直接使用必须实例化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>x</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ✓ 正确。 这里传入了类型实参int，将泛型类型Slice[T]实 例化为具体的类型 Slice[int]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span> <span class=nx>Slice</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Type Name: %T&#34;</span><span class=p>,</span><span class=nx>a</span><span class=p>)</span>  <span class=c1>//输出：Type Name: Slice[int]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 传入类型实参float32, 将泛型类型Slice[T]实例化为具体的类型 Slice[string]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>b</span> <span class=nx>Slice</span><span class=p>[</span><span class=kt>float32</span><span class=p>]</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>float32</span><span class=p>{</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Type Name: %T&#34;</span><span class=p>,</span><span class=nx>b</span><span class=p>)</span>  <span class=c1>//输出：Type Name: Slice[float32]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// ✗ 错误。因为变量a的类型为Slice[int]，b的类型为Slice[float32]，两者类型不同
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nx>b</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ✗ 错误。string不在类型约束 int|float32 中，不能用来实例化泛型类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>c</span> <span class=nx>Slice</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=s>&#34;World&#34;</span><span class=p>}</span> 
</span></span></code></pre></td></tr></table></div></div><p>在上面的例子中，我们首先通过给泛型类型 <code>Slice[T]</code> 传入了类型实参 <code>int</code> ，将其实例化为了具体的类型 <code>Slice[int]</code> 。这时候我们就可以把它的类型定义视为 <code>type Slice[int] []int</code> 。其中实例化后的类型名为 <code>Slice[int]</code> ，其底层类型是 <code>[]int</code> 。后面传入float32实例化同理。</p><p>并且因为经过实例化之后，变量 a 和 b 就是具体的不同类型了(一个 Slice[int] ，一个 Slice[float32]），所以 <code>a = b</code> 这样不同类型之间的变量赋值是不允许的。</p><p>同时，因为 Slice[T] 的类型约束限定了只能使用 int 和 float32 来实例化自己，所以所以 <code>Slice[string]</code> 这样使用 string 类型来实例化是错误的。</p><p>上面只是个最简单的例子，实际上类型形参可以远远不止一个，并且也可以使用在任何类型的定义之中，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// MyMap类型定义了两个类型形参 KEY 和 VALUE。分别为两个形参制定了不同的类型约束
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>MyMap</span><span class=p>[</span><span class=nx>KEY</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>VALUE</span> <span class=kt>float32</span> <span class=p>|</span> <span class=kt>float64</span><span class=p>]</span> <span class=kd>map</span><span class=p>[</span><span class=nx>KEY</span><span class=p>]</span><span class=nx>VALUE</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 分别用类型实参 string flaot64 替换了类型形参 KEY 和 VALUE 来实例化泛型类型MyMap[KEY, VALUE]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span> <span class=nx>MyMap</span><span class=p>[</span><span class=kt>string</span><span class=p>,</span> <span class=kt>float64</span><span class=p>]</span> <span class=p>=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>float64</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;jack_score&#34;</span><span class=p>:</span> <span class=mf>9.6</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;bob_score&#34;</span><span class=p>:</span>  <span class=mf>8.4</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>用上面的例子重新复习下各种概念的话：</p><ul><li>KEY和VALUE是<strong>类型形参</strong></li><li><code>int|string</code> 是KEY的<strong>类型约束</strong>， <code>float32|float64</code> 是类型VALUE的<strong>类型约束</strong></li><li><code>KEY int|string, VALUE float32|float64</code> 整个一串文本被称为<strong>类型形参列表</strong></li><li>Map[KEY, VALUE] 是<strong>泛型类型</strong>，类型名称为 Map[KEY, VALUE]</li><li><code>var a MyMap[string, float64] = xx</code> 中的string和float64是<strong>类型实参</strong>，用于分别替换KEY和VALUE，<strong>实例化</strong>出了具体的类型 <code>MyMap[string, float64]</code></li></ul><p>还有点头晕？没事，的确一下子有太多概念了，这里用一张图就能简单说清楚：</p><p><img src=https://segmentfault.com/img/bVcYRiO alt=img></p><p>Go泛型概念一览</p><h3 id=31-其他的泛型类型>3.1 其他的泛型类型</h3><p>除此之外还有诸如结构体以及接口之类的定义也能使用类型形参：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 一个泛型类型的结构体。可用 int 或 sring 类型实例化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>MyStruct</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>string</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 一个泛型接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>PrintData</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>float32</span> <span class=p>|</span> <span class=kt>string</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Print</span><span class=p>(</span><span class=nx>data</span> <span class=nx>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 一个泛型类型通道，可用类型实参 int 或 string 实例化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>MyChan</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>string</span><span class=p>]</span> <span class=kd>chan</span> <span class=nx>T</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=32-类型形参的互相套用>3.2 类型形参的互相套用</h3><p>在类型形参列表中的类型形参是可以互相套用的，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WowStruct</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>float32</span><span class=p>,</span> <span class=nx>S</span> <span class=p>[]</span><span class=nx>T</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span>     <span class=nx>S</span>
</span></span><span class=line><span class=cl>    <span class=nx>MaxValue</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl>    <span class=nx>MinValue</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个例子看起来有点复杂且难以理解，但实际上只要记住一点，任何泛型类型都必须传入类型实参实例化才可以使用就容易理解了。我们这就尝试传入下类型实参看看就：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ws</span> <span class=o>:=</span> <span class=nx>WowStruct</span><span class=p>[</span><span class=kt>int</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>]{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Data</span><span class=p>:</span>     <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=nx>MaxValue</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>MinValue</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在这个例子中，类型形参的定义是 []T ，而我们给 T 传入了类型实参 int ，所以 S 就应该传入类型实参 <code>[]int</code> 。如果像下面这样的话则是错误的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 错误。S的定义是[]T，这里T传入了实参int,所以S的类型应当为 []int 而不是 []float
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ws</span> <span class=o>:=</span> <span class=nx>WowStruct</span><span class=p>[</span><span class=kt>int</span><span class=p>,</span> <span class=p>[]</span><span class=kt>float</span><span class=p>]{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Data</span><span class=p>:</span>     <span class=p>[]</span><span class=kt>float</span><span class=p>{</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=nx>MaxValue</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>MinValue</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>传入类型实参后，泛型类型 <code>WowStuct[T, S]</code> 被实例化，生成了一个新的具体的类型 <code>WowStruct[int, []int]</code> ，这个类型的定义可近似视为如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WowStruct</span><span class=p>[</span><span class=kt>int</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span>     <span class=p>[]</span><span class=nx>iont</span>
</span></span><span class=line><span class=cl>    <span class=nx>MaxValue</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>MinValue</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=33-几种语法错误>3.3 几种语法错误</h3><ol><li><p>定义泛型类型的时候，<strong>不能只有类型形参</strong>，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 错误，类型形参不能单独使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>CommonType</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span><span class=p>|</span><span class=kt>string</span><span class=p>|</span><span class=kt>float32</span><span class=p>]</span> <span class=nx>T</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>当类型约束的一些写法会被编译器误认为表达式时会报错。如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//✗ 错误。T *int会被编译器误认为是表达式 （T乘以int)，所以在编译器眼中这行代码是下面这样的：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>NewType</span><span class=p>[</span><span class=nx>T</span> <span class=o>*</span><span class=kt>int</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=c1>// 编译器眼中的代码：认为要定义一个存放切片的数组，数组长度由 T * int 计算得到
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>NewType</span> <span class=p>[</span><span class=nx>T</span> <span class=o>*</span> <span class=kt>int</span><span class=p>][]</span><span class=nx>T</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//✗ 错误。和上面一样，这里不光*被会认为是乘号，|还会被认为是按位或操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>NewType2</span><span class=p>[</span><span class=nx>T</span> <span class=o>*</span><span class=kt>int</span><span class=p>|</span><span class=o>*</span><span class=kt>float64</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//✗ 错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>NewType2</span> <span class=p>[</span><span class=nf>T</span> <span class=p>(</span><span class=kt>int</span><span class=p>)]</span> <span class=p>[]</span><span class=nx>T</span> 
</span></span></code></pre></td></tr></table></div></div><p>为了避免这种误解，解决办法就是给类型约束包上 <code>interface{}</code> 或加上逗号（具体关于接口相关的用法会在后半篇提及）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>NewType</span><span class=p>[</span><span class=nx>T</span> <span class=kd>interface</span><span class=p>{</span><span class=o>*</span><span class=kt>int</span><span class=p>}]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>NewType2</span><span class=p>[</span><span class=nx>T</span> <span class=kd>interface</span><span class=p>{</span><span class=o>*</span><span class=kt>int</span><span class=p>|</span><span class=o>*</span><span class=kt>float64</span><span class=p>}]</span> <span class=p>[]</span><span class=nx>T</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果类型约束中只有一个类型，可以添加个逗号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>NewType3</span><span class=p>[</span><span class=nx>T</span> <span class=o>*</span><span class=kt>int</span><span class=p>,]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//✗ 错误。如果类型约束不止一个类型，加逗号也会报错
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>NewType4</span><span class=p>[</span><span class=nx>T</span> <span class=o>*</span><span class=kt>int</span><span class=p>|</span><span class=o>*</span><span class=kt>float32</span><span class=p>,]</span> <span class=p>[]</span><span class=nx>T</span> 
</span></span></code></pre></td></tr></table></div></div><p>因为上面逗号的用法限制比较大而且记忆负担较重，这里推荐不使用逗号而是清一色全用interface{}解决问题</p></li></ol><h3 id=34-特殊的泛型类型>3.4 特殊的泛型类型</h3><p>这里讨论种比较特殊的泛型类型，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Wow</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>string</span><span class=p>]</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=nx>Wow</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=p>=</span> <span class=mi>123</span>     <span class=c1>// 编译正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>b</span> <span class=nx>Wow</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> <span class=p>=</span> <span class=mi>123</span>  <span class=c1>// 编译正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>c</span> <span class=nx>Wow</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;hello&#34;</span> <span class=c1>// 编译错误，因为&#34;hello&#34;不能赋值给底层类型int
</span></span></span></code></pre></td></tr></table></div></div><p>这里虽然使用了类型形参，但因为类型定义是 <code>type Wow[T int|string] int</code> ，所以无论传入什么类型实参，实例化后的新类型的底层类型都是 int 。所以int类型的数字123可以赋值给变量a和b，但string类型的字符串 “hello” 不能赋值给c</p><p>这个例子没有什么具体意义，但是可以让我理解泛型类型的实例化的机制</p><h3 id=35-泛型类型的套娃>3.5 泛型类型的套娃</h3><p>泛型和普通的类型一样，可以互相嵌套定义出更加复杂的新类型，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span><span class=p>|</span><span class=kt>string</span><span class=p>|</span><span class=kt>float32</span><span class=p>|</span><span class=kt>float64</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ✗ 错误。泛型类型Slice的类型约束中不包含uint, uint8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>UintSlice</span><span class=p>[</span><span class=nx>T</span> <span class=kt>uint</span><span class=p>|</span><span class=kt>uint8</span><span class=p>]</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ✓ 正确。基于泛型类型Slice定义了新的泛型类型 FloatSlice 。FloatSlice只接受float32和float64两种类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>FloatSlice</span><span class=p>[</span><span class=nx>T</span> <span class=kt>float32</span><span class=p>|</span><span class=kt>float64</span><span class=p>]</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ✓ 正确。基于泛型类型Slice定义的新泛型类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>IntAndStringSlice</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span><span class=p>|</span><span class=kt>string</span><span class=p>]</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=c1>// ✓ 也正确 基于IntAndStringSlice定义出的新泛型类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>IntSlice</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span><span class=p>]</span> <span class=nx>IntAndStringSlice</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 在map中套一个泛型类型Slice[T]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>WowMap</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span><span class=p>|</span><span class=kt>string</span><span class=p>]</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1>// 在map中套Slice的另一种写法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>WowMap2</span><span class=p>[</span><span class=nx>T</span> <span class=nx>Slice</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=p>|</span> <span class=nx>Slice</span><span class=p>[</span><span class=kt>string</span><span class=p>]]</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>T</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=36-泛型约束的两种选择>3.6 泛型约束的两种选择</h3><p>观察下面两种类型约束的写法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WowStruct</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span><span class=p>|</span><span class=kt>string</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WowStruct2</span><span class=p>[</span><span class=nx>T</span> <span class=p>[]</span><span class=kt>int</span><span class=p>|[]</span><span class=kt>string</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>仅限于这个例子，这两种写法和实现的功能其实是差不多的，实例化之后内部结构体的相同。但是但是像下面这种情况的时候，我们使用前一种写法会更好：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WowStruct3</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>string</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span>     <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl>    <span class=nx>MaxValue</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl>    <span class=nx>MinValue</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=37-匿名结构体不支持泛型>3.7 匿名结构体不支持泛型</h3><p>我们有时候会经常使用到匿名的结构体(struct)并在定义之后直接初始化匿名结构体，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>testCase</span> <span class=o>:=</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>caseName</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>got</span>      <span class=kt>int</span>
</span></span><span class=line><span class=cl>        <span class=nx>want</span>     <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=p>}{</span>
</span></span><span class=line><span class=cl>        <span class=nx>caseName</span><span class=p>:</span> <span class=s>&#34;test OK&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>got</span><span class=p>:</span>      <span class=mi>100</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>want</span><span class=p>:</span>     <span class=mi>100</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>那么匿名结构体能不能使用泛型呢？答案是不能，所以下面的用法是错误的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>testCase</span> <span class=o>:=</span> <span class=kd>struct</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span><span class=p>|</span><span class=kt>string</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>caseName</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>got</span>      <span class=nx>T</span>
</span></span><span class=line><span class=cl>        <span class=nx>want</span>     <span class=nx>T</span>
</span></span><span class=line><span class=cl>    <span class=p>}[</span><span class=kt>int</span><span class=p>]{</span>
</span></span><span class=line><span class=cl>        <span class=nx>caseName</span><span class=p>:</span> <span class=s>&#34;test OK&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>got</span><span class=p>:</span>      <span class=mi>100</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>want</span><span class=p>:</span>     <span class=mi>100</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>解决办法就是用泛型的时候给结构体命名，不用匿名结构，。对于很多场景的使用来说确实比较麻烦（最主要麻烦集中在单元测试的时候，对泛型函数之类的做单元测试会变得非常麻烦，这点我之后的文章将会详细阐述）</p><h2 id=4-泛型receiver>4. 泛型receiver</h2><p>看了上的例子，你一定会说，介绍了这么多复杂的概念，但好像泛型类型根本没什么用处啊？</p><p>是的，单纯的泛型类型实际上对开发来说用处并不大。但是如果将泛型类型和接下来要介绍的泛型receiver相结合的话，泛型就有了非常大的实用性了</p><p>我们知道，定义了新的普通类型之后可以给类型添加方法。那么可以给泛型类型添加方法吗？答案自然是可以的，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MySlice</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>float32</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>MySlice</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Sum</span><span class=p>()</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>sum</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>value</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>value</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>sum</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个例子为泛型类型 <code>MySlice[T]</code> 添加了一个计算成员总和的方法 <code>Sum()</code> 。注意观察这个方法的定义：</p><ul><li>首先看receiver <code>(s MySlice[T])</code> ，因为上面这种泛型类型的名称叫 <code>MySlice[T]</code> ，所以我们直接把类型名写入了receiverr中</li><li>然后方法的返回参数我们也使用了<strong>类型形参</strong>(实际上如果有需要的话，方法的接收参数也可以实用类型形参)</li><li>在方法的定义中，我们也可以实用类型形参T，这里我们定义了一个新的变量sum : <code>var sum T</code></li></ul><p>对于这个泛型类型 <code>MySlice[T]</code> 我们该如何使用？还记不记得之前强调过很多次的，泛型类型无论如何都需要先用类型实参实例化，所以用法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=nx>MySlice</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nf>Sum</span><span class=p>())</span> <span class=c1>// 输出：10
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s2</span> <span class=nx>MySlice</span><span class=p>[</span><span class=kt>float32</span><span class=p>]</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>float32</span><span class=p>{</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>,</span> <span class=mf>4.0</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s2</span><span class=p>.</span><span class=nf>Sum</span><span class=p>())</span> <span class=c1>// 输出：10.0
</span></span></span></code></pre></td></tr></table></div></div><p>该如何理解上面的实例化？首先我们用类型实参 int 实例化了泛型类型 <code>MySlice[T]</code>，所以泛型类型定义中的所有T都被替换为int，最终我们可以把代码看作下面这样这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MySlice</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=p>[]</span><span class=kt>int</span> <span class=c1>// 实例化后的类型名叫 MyIntSlice[int]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 方法 中所有类型形参 T 被替换为类型实参
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>MySlice</span><span class=p>[</span><span class=kt>int</span><span class=p>])</span> <span class=nf>Sum</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>sum</span> <span class=kt>int</span> 
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>value</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>value</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>sum</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>用float32实例化和用int实例化同理，此处不再赘述。</p><p>通过泛型receiver，泛型的实用性一下子得到了巨大的扩展。在没有泛型之前，如果想实现诸如堆，栈、队列、链表之类的数据结构，我们要么</p><ol><li>为每种类型写一个实现</li><li>使用 interface{} 接口</li></ol><p>而有了泛型之后，我们就能非常简单地创建通用地数据结构结构了。接下来用一个更加实用地例子——队列来讲解</p><h3 id=41-基于泛型的队列>4.1 基于泛型的队列</h3><p>队列是一种先入先出的数据结构，它和现实中排队一样，数据只能从队尾部放入和从队首取出，先放入的数据优先被取出来</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 这里类型约束使用了空接口，代表的意思是所有类型都可以用来实例化泛型类型 Queue[T]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span> <span class=kd>interface</span><span class=p>{}]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>elements</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 将数据放入队列尾部
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Put</span><span class=p>(</span><span class=nx>value</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>q</span><span class=p>.</span><span class=nx>elements</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>q</span><span class=p>.</span><span class=nx>elements</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 从队列头部取出并从头部删除对应数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Pop</span><span class=p>()</span> <span class=p>(</span><span class=nx>T</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>value</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>q</span><span class=p>.</span><span class=nx>elements</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>value</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>value</span> <span class=p>=</span> <span class=nx>q</span><span class=p>.</span><span class=nx>elements</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>q</span><span class=p>.</span><span class=nx>elements</span> <span class=p>=</span> <span class=nx>q</span><span class=p>.</span><span class=nx>elements</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>value</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 队列大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Size</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>q</span><span class=p>.</span><span class=nx>elements</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>💡 为了方便说明，上面是队列非常简单的一种实现方法，没有考虑线程安全等很多问题</p><p>首先观察结构体的类型形参列表 <code>T interface{}</code> ，类型约束使用了一个空接口，当类型约束使用空接口的时候并不代表这个泛型类型只能像下面这样使用空接口实例化： <code>var q Queue[interface{}]</code>，而是所有类型都可用来实例化(关于接口相关地详细说明参考后半部分说明）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>q1</span> <span class=nx>Queue</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span>  <span class=c1>// 可存放int类型数据的队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q1</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>q1</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>q1</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>q1</span><span class=p>.</span><span class=nf>Pop</span><span class=p>()</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q1</span><span class=p>.</span><span class=nf>Pop</span><span class=p>()</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q1</span><span class=p>.</span><span class=nf>Pop</span><span class=p>()</span> <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>q2</span> <span class=nx>Queue</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span>  <span class=c1>// 可存放string类型数据的队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q2</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=s>&#34;A&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>q2</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=s>&#34;B&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>q2</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=s>&#34;C&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>q2</span><span class=p>.</span><span class=nf>Pop</span><span class=p>()</span> <span class=c1>// &#34;A&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q2</span><span class=p>.</span><span class=nf>Pop</span><span class=p>()</span> <span class=c1>// &#34;B&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q2</span><span class=p>.</span><span class=nf>Pop</span><span class=p>()</span> <span class=c1>// &#34;C&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>q3</span> <span class=nx>Queue</span><span class=p>[</span><span class=kd>struct</span><span class=p>{</span><span class=nx>Name</span> <span class=kt>string</span><span class=p>}]</span> 
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>q4</span> <span class=nx>Queue</span><span class=p>[[]</span><span class=kt>int</span><span class=p>]</span> <span class=c1>// 可存放[]int切片的队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>q5</span> <span class=nx>Queue</span><span class=p>[</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>]</span> <span class=c1>// 可存放int通道的队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>q6</span> <span class=nx>Queue</span><span class=p>[</span><span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>]</span> <span class=c1>// 可存放接口的队列
</span></span></span><span class=line><span class=cl><span class=c1>// ......
</span></span></span></code></pre></td></tr></table></div></div><h3 id=42-动态判断变量的类型>4.2 动态判断变量的类型</h3><p>使用接口的时候经常会用到类型断言或 type swith 来确定接口具体的类型，然后对不同类型做出不同的处理，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>i</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>=</span> <span class=mi>123</span>
</span></span><span class=line><span class=cl><span class=nx>i</span><span class=p>.(</span><span class=kt>int</span><span class=p>)</span> <span class=c1>// 类型断言
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// type switch
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>switch</span> <span class=nx>i</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=kt>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=kt>string</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>那么你一定会想到，对于 <code>valut T</code> 这样通过类型形参定义的变量，我们能不能判断具体类型然后对不同类型做出不同处理呢？答案是不允许的，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Put</span><span class=p>(</span><span class=nx>value</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 错误。不允许使用type switch 来判断 value 的具体类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>switch</span> <span class=nx>T</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=kt>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=kt>string</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>虽然type switch不能，可通过反射机制我们就能曲线救国完成对应的功能：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>receiver</span> <span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Put</span><span class=p>(</span><span class=nx>value</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Printf() 可输出变量value的类型(底层就是通过反射实现的)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%T&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 通过反射可以动态获得变量value类型从而分情况处理
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>valueType</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=nx>valueType</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>String</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这看起来达到了我们的目的，可是当你写出上面这样的代码时候就出现了一个问题：</p><p>你为了避免使用反射而选择了泛型，结果到头来又为了一些功能在在泛型中使用反射。当出现这种情况的时候你可能需要重新思考一下，自己的需求是不是真的需要用泛型（毕竟泛型机制本身就很复杂了，再加上反射的复杂度，增加的复杂度并不一定值得）</p><p>当然，这一切选择权都在你自己的手里，根据具体情况斟酌</p><h2 id=5-泛型函数>5. 泛型函数</h2><p>在介绍完泛型类型和泛型receiver之后，我们来介绍最后一个可以使用泛型的地方——泛型函数。有了上面的知识，写泛型函数也十分简单。假设我们想要写一个计算两个数之和的函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>a</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个函数理所当然只能计算int的和，而浮点的计算是不支持的。这时候我们可以像下面这样定义一个泛型函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>Add</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>float32</span> <span class=p>|</span> <span class=kt>float64</span><span class=p>](</span><span class=nx>a</span> <span class=nx>T</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上面就是泛型函数的定义——这种带类型形参的函数被称为<strong>泛型函数</strong>。它和普通函数的不同在于函数名之后带了类型形参。这里的类型形参的意义、写法和用法因为与泛型类型是一模一样的，就不再赘述了。</p><p>和泛型类型一样，泛型函数也是不能直接调用的，要使用泛型函数的话必须传入类型实参之后才能调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>Add</span><span class=p>[</span><span class=kt>int</span><span class=p>](</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span> <span class=c1>// 传入类型实参int，计算结果为 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>Add</span><span class=p>[</span><span class=kt>float32</span><span class=p>](</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>)</span> <span class=c1>// 传入类型实参float32, 计算结果为 3.0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>Add</span><span class=p>[</span><span class=kt>string</span><span class=p>](</span><span class=s>&#34;hello&#34;</span><span class=p>,</span> <span class=s>&#34;world&#34;</span><span class=p>)</span> <span class=c1>// 错误。因为泛型函数Add的类型约束中并不包含string
</span></span></span></code></pre></td></tr></table></div></div><p>或许你会觉得这样每次都要手动指定类型实参太不方便了。所以Go还支持类型实参的自动推导：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>  <span class=c1>// 1，2是int类型，编译请自动推导出类型实参T是int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>Add</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>)</span> <span class=c1>// 1.0, 2.0 是浮点，编译请自动推导出类型实参T是float32
</span></span></span></code></pre></td></tr></table></div></div><p>自动推导的写法就好像免去了传入实参的步骤一样，但请记住这仅仅只是编译器帮我们推导出了类型实参，实际上传入实参步骤还是发生了的。</p><h3 id=51-匿名函数不支持泛型>5.1 匿名函数不支持泛型</h3><p>在Go中我们经常会使用匿名函数，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fn</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>  <span class=c1>// 定义了一个匿名函数并赋值给 fn 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>fn</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span> <span class=c1>// 输出: 3
</span></span></span></code></pre></td></tr></table></div></div><p>那么Go支不支持匿名泛型函数呢？答案是不能——匿名函数签名中不能包含类型形参：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 错误，不支持匿名泛型函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fnGeneric</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>float32</span><span class=p>](</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>fnGeneric</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>但是在匿名函数中使用类型形参是可以：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>MyFunc</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>string</span><span class=p>](</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fn</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>c</span> <span class=nx>T</span>     <span class=c1>// 匿名函数可使用类型形参
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>c</span> <span class=p>=</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fn</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=52-既然支持泛型函数那么泛型方法呢>5.2 既然支持泛型函数，那么泛型方法呢？</h3><p>既然函数都支持了泛型了，那你应该自然会想到，方法支不支持泛型？很不幸，目前Go的方法并不支持泛型，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>A</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 不支持泛型方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>receiver</span> <span class=nx>A</span><span class=p>)</span> <span class=nx>Add</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>float32</span> <span class=p>|</span> <span class=kt>float64</span><span class=p>](</span><span class=nx>a</span> <span class=nx>T</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>但是因为receiver支持泛型， 所以如果想在方法中使用泛型的话，目前唯一的办法就是曲线救国，迂回地在类型中定义形参：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>A</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>float32</span> <span class=p>|</span> <span class=kt>float64</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 方法可以使用类型定义中的形参 T 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>receiver</span> <span class=nx>A</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>a</span> <span class=nx>T</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 用法：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span> <span class=nx>A</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>aa</span> <span class=nx>A</span><span class=p>[</span><span class=kt>float32</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>aa</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=前半小结>前半小结</h2><p>讲完了泛型类型、泛型receiver、泛型函数后，Go的泛型算是介绍完一半多了。在这里我们做一个概念的小结：</p><ol><li>Go的泛型目前可使用在3个地方<ol><li>泛型类型 - 类型定义中带类型形参的类型</li><li>泛型receiver - 泛型类型的receiver</li><li>泛型函数 - 带类型形参的函数</li></ol></li><li>为了实现泛型，Go引入了一些新的概念：<ol><li>类型形参</li><li>类型形参列表</li><li>类型实参</li><li>类型约束</li><li>实例化 - 泛型类型不能直接使用，要使用的话必须传入类型实参进行实例化</li></ol></li></ol><p>什么，这文章已经很长很复杂了，才讲了一半？是的，Go这次1.18引入泛型为语言增加了较大的复杂度，目前还只是新概念的介绍，下面后半段将介绍Go引入泛型后对接口做出的重大调整。那么做好心理准备，我们出发吧。</p><h2 id=6-变得复杂的接口>6. 变得复杂的接口</h2><p>有时候使用泛型编程时，我们会书写长长的类型约束，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 一个可以容纳所有int,uint以及浮点类型切片的泛型类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=kt>int</span> <span class=p>|</span> <span class=kt>int8</span> <span class=p>|</span> <span class=kt>int16</span> <span class=p>|</span> <span class=kt>int32</span> <span class=p>|</span> <span class=kt>int64</span> <span class=p>|</span> <span class=kt>uint</span> <span class=p>|</span> <span class=kt>uint8</span> <span class=p>|</span> <span class=kt>uint16</span> <span class=p>|</span> <span class=kt>uint32</span> <span class=p>|</span> <span class=kt>uint64</span> <span class=p>|</span> <span class=kt>float32</span> <span class=p>|</span> <span class=kt>float64</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span></code></pre></td></tr></table></div></div><p>理所当然，这种写法是我们无法忍受也难以维护的，而Go支持将类型约束单独拿出来定义到接口中，从而让代码更容易维护：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>IntUintFloat</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>|</span> <span class=kt>int8</span> <span class=p>|</span> <span class=kt>int16</span> <span class=p>|</span> <span class=kt>int32</span> <span class=p>|</span> <span class=kt>int64</span> <span class=p>|</span> <span class=kt>uint</span> <span class=p>|</span> <span class=kt>uint8</span> <span class=p>|</span> <span class=kt>uint16</span> <span class=p>|</span> <span class=kt>uint32</span> <span class=p>|</span> <span class=kt>uint64</span> <span class=p>|</span> <span class=kt>float32</span> <span class=p>|</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=nx>IntUintFloat</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span></code></pre></td></tr></table></div></div><p>这段代码把类型约束给单独拿出来，写入了接口类型 <code>IntUintFloat</code> 当中。需要指定类型约束的时候直接使用接口 <code>IntUintFloat</code> 即可。</p><p>不过这样的代码依旧不好维护，而接口和接口、接口和普通类型之间也是可以通过 <code>|</code> 进行组合：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Int</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>|</span> <span class=kt>int8</span> <span class=p>|</span> <span class=kt>int16</span> <span class=p>|</span> <span class=kt>int32</span> <span class=p>|</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Uint</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=p>|</span> <span class=kt>uint8</span> <span class=p>|</span> <span class=kt>uint16</span> <span class=p>|</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Float</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float32</span> <span class=p>|</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=nx>Int</span> <span class=p>|</span> <span class=nx>Uint</span> <span class=p>|</span> <span class=nx>Float</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span>  <span class=c1>// 使用 &#39;|&#39; 将多个接口类型组合
</span></span></span></code></pre></td></tr></table></div></div><p>上面的代码中，我们分别定义了 Int, Uint, Float 三个接口类型，并最终在 Slice[T] 的类型约束中中通过使用 <code>|</code> 将它们组合到一起。</p><p>同时，接口也能组合其他接口，所以还可以像下面这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SliceElement</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Int</span> <span class=p>|</span> <span class=nx>Uint</span> <span class=p>|</span> <span class=nx>Float</span> <span class=p>|</span> <span class=kt>string</span> <span class=c1>// 组合了三个接口类型并额外增加了一个 string 类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=nx>SliceElement</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span> 
</span></span></code></pre></td></tr></table></div></div><h3 id=61---指定底层类型>6.1 <code>~</code> : 指定底层类型</h3><p>上面定义的Slie[T]虽然可以达到目的，但是有一个缺点：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s1</span> <span class=nx>Slice</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=c1>// 正确 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyInt</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s2</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>MyInt</span><span class=p>]</span> <span class=c1>// ✗ 错误。MyInt类型底层类型是int但并不是int类型，不符合 Slice[T] 的类型约束
</span></span></span></code></pre></td></tr></table></div></div><p>这里发生错误的原因是，泛型类型 <strong>Slice[T]</strong> 允许的是 <strong>int</strong> 作为类型实参，而不是 MyInt （虽然 MyInt 类型底层类型是 int ，但它依旧不是 int 类型）。</p><p>为了从根本上解决这个问题，Go新增了一个符号 <code>~</code> ，在类型约束中使用类似 <code>~int</code> 这种写法的话，就代表着不光是 int ，所有以 int 为底层类型的类型也都可用于实例化。</p><p>使用 ~ 对代码进行改写之后如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Int</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Uint</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Float</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>float32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=nx>Int</span> <span class=p>|</span> <span class=nx>Uint</span> <span class=p>|</span> <span class=nx>Float</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=nx>Slice</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyInt</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s2</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>MyInt</span><span class=p>]</span>  <span class=c1>// MyInt底层类型是int，所以可以用于实例化
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyMyInt</span> <span class=nx>MyInt</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s3</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>MyMyInt</span><span class=p>]</span>  <span class=c1>// 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyFloat32</span> <span class=kt>float32</span>  <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s4</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>MyFloat32</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>限制</strong>：使用 <code>~</code> 时有一定的限制：</p><ol><li>~后面的类型不能为接口</li><li>~后面的类型必须为底层类型</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyInt</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>_</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=p>[]</span><span class=kt>byte</span>  <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=err>~</span><span class=nx>MyInt</span>   <span class=c1>// 错误，~后的类型必须为底层类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=err>~</span><span class=kt>error</span>   <span class=c1>// 错误，~后的类型不能为接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=62-从方法集method-set到类型集type-set>6.2 从方法集(Method set)到类型集(Type set)</h3><p>上面的例子中，我们学习到了一种接口的全新写法，而这种写法在Go1.18之前是不存在的。如果你比较敏锐的话，一定会隐约认识到这种写法的改变这也一定意味着Go语言中 <code>接口(interface{})</code> 这个概念发生了非常大的变化。</p><p>是的，在Go1.18之前，Go官方对 <code>接口(interface)</code> 的定义为：接口是一个方法集(method set)</p><blockquote><p>An interface type specifies a <strong>method set</strong> called its interface</p></blockquote><p>就如下面这个代码一样， <code>ReadWriter</code> 接口定义了一个接口(方法集)，这个集合中包含了 <code>Read()</code> 和 <code>Write()</code> 这两个方法。所有同时定义了这两种方法的类型被视为实现了这一接口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ReadWriter</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>但是，我们如果换一个角度来重新思考上面这个接口的话，会发现接口的定义实际上还能这样理解：</p><blockquote><p>我们可以把 <code>ReaderWriter</code> 接口看成代表了一个 <strong>类型的集合</strong>，所有实现了 <code>Read()</code> <code>Writer()</code> 这两个方法的类型都在接口代表的类型集合当中</p></blockquote><p>通过换个角度看待接口，在我们眼中接口的定义就从 <strong><code>方法集(method set)</code></strong> 变为了 <strong><code>类型集(type set)</code></strong>。而Go1.18开始就是依据这一点将接口的定义正式更改为了 <strong>类型集(Type set)</strong></p><blockquote><p>An interface type defines a ***type set
(***一种接口类型定义了一个类型集)</p></blockquote><p>你或许会觉得，这不就是改了下概念上的定义实际上没什么用吗？是的，如果接口功能没变化的话确实如此。但是还记得下面这种用接口来简化类型约束的写法吗：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Float</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>float32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=nx>Float</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span> 
</span></span></code></pre></td></tr></table></div></div><p>这就体现出了为什么要更改接口的定义了。用 <strong>方法集</strong> 的概念重新理解下上面的代码：</p><blockquote><p>接口类型 Float 代表了一个 <strong>类型集合</strong>， 所有以 float32 <strong>或</strong> float64为底层类型的类型，都在这一类型集之中</p></blockquote><p>而泛型类型 Slice[T] 的 <strong>类型约束</strong> 的真正意思是： 类型约束指定了对应类型形参可用的类型集合，只有属于这个集合中的类型才能替换形参用于泛型类型的实例化，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var s Slice[int]          // int 类型属于 T 的类型约束限定的类型集，所以int可以作为类型实参
</span></span><span class=line><span class=cl>var s Slice[chan int] // chan int 类型不在T的类型约束限定的类型集中，所以错误
</span></span></code></pre></td></tr></table></div></div><h4 id=621-接口实现implement定义的变化>6.2.1 接口实现(implement)定义的变化</h4><p>既然接口定义发生了变化，那么从Go1.18开始 <code>接口实现(implement)</code> 的定义自然也发生了变化：</p><p>当满足以下条件时，我们可以说 <strong>类型 T 实现了接口 I ( type T implements interface I)</strong>：</p><ul><li>T 不是接口时：类型 T 时接口代表的类型集中的一个成员 (T is an element of the type set of I)</li><li>T 是接口时： T 接口代表的类型集是 I 代表的类型集的子集(Type set of T is a subset of the type set of I)</li></ul><h4 id=622-类型的并集>6.2.2 <strong>类型的并集</strong></h4><p>并集我们已经很熟悉了，之前一直使用的 <code>|</code> 符号就是求类型的并集( <code>union</code> )</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Uint</span> <span class=kd>interface</span> <span class=p>{</span>  <span class=c1>// 类型集 Uint 是 ~uint 和 ~uint8 等类型的并集
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=623-类型的交集>6.2.3 类型的交集</h4><p>接口可以不止书写一行，如果一个接口有多行类型定义，那么取它们之间的 <strong>交集</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>AllInt</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int64</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Uint</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>A</span> <span class=kd>interface</span> <span class=p>{</span> <span class=c1>// 接口A代表的类型集是 AllInt 和 Uint 的交集
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>AllInt</span>
</span></span><span class=line><span class=cl>    <span class=nx>Uint</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>B</span> <span class=kd>interface</span> <span class=p>{</span> <span class=c1>// 接口B代表的类型集是 AllInt 和 ~int 的交集
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>AllInt</span>
</span></span><span class=line><span class=cl>  <span class=err>~</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上面这个例子中</p><ul><li>接口 A 代表的是 AllInt 与 Uint 的 <strong>交集</strong>，即 <code>~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64</code></li><li>接口 B 代表的则是 AllInt 和 ~int 的<strong>交集</strong></li></ul><p>上面的代码等价于如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>A</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>B</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>~</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>除了上面的交集，下面也是一种交集：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>C</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>很显然，~int 和 int 的交集只有int一种类型，所以接口C代表的类型集中只有int一种类型</p><h4 id=624-空集>6.2.4 空集</h4><p>当多个类型的交集如下面 <code>Bad</code> 这样为空的时候， <code>Bad</code> 这个接口代表的类型集为一个<strong>空集</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Bad</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=kt>float32</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// 类型 int 和 float32 没有相交的类型，所以接口 Bad 代表的类型集为空
</span></span></span></code></pre></td></tr></table></div></div><p><strong>没有任何一种类型属于空集</strong>。所以虽然Bad这样的写法是可以编译的，但实际上并没有什么意义</p><h4 id=625-空接口和-any>6.2.5 空接口和 any</h4><p>上面说了空集，接下来说一个特殊的集合，空接口 <code>interface{}</code> 。因为，Go1.18开始接口的定义发生了改变，所以 <code>interface{}</code> 的定义也发生了一些变更：</p><blockquote><p>空接口代表所有类型的集合</p></blockquote><p>所以，对于Go1.18之后的空接口应该这样理解：</p><ol><li><p>虽然空接口内没有写入任何的类型，但它代表的是所有类型的集合，而非一个 <code>空集</code></p></li><li><p>类型约束中指定 <strong>空接口</strong> 的意思是指定了一个包含所有类型的类型集，并不是类型约束限定了只能使用 空接口 来做类型形参</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 空接口代表所有类型的集合。写入类型约束意味着所有类型都可拿来做类型实参
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=kd>interface</span><span class=p>{}]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s1</span> <span class=nx>Slice</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span>    <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s2</span> <span class=nx>Slice</span><span class=p>[</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>]</span> <span class=nx>T</span>  <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s3</span> <span class=nx>Slice</span><span class=p>[</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>]</span>  <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s4</span> <span class=nx>Slice</span><span class=p>[</span><span class=kd>interface</span><span class=p>{}]</span>  <span class=c1>// 正确
</span></span></span></code></pre></td></tr></table></div></div></li></ol><p>因为空接口是一个包含了所有类型的类型集，所以我们经常会用到它。于是，Go1.18开始提供了一个和空接口 <code>interface{}</code> 等价的新关键词 <code>any</code> ，用来使代码更简单：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Slice</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=p>[]</span><span class=nx>T</span> <span class=c1>// 代码等价于 type Slice[T interface{}] []T
</span></span></span></code></pre></td></tr></table></div></div><p>实际上 <code>any</code> 的定义就位于Go语言的 <code>builtin.go</code> 文件中（参考如下）， <code>any</code> 实际上就是 <code>interaface{}</code> 的别名(alias)，两者完全等价</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// any is an alias for interface{} and is equivalent to interface{} in all ways.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>any</span> <span class=p>=</span> <span class=kd>interface</span><span class=p>{}</span> 
</span></span></code></pre></td></tr></table></div></div><p>所以从go 1.18开始，所有可以用到空接口的地方其实都可以直接替换为any。如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=p>[]</span><span class=nx>any</span> <span class=c1>// 等价于 var s []interface{}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span> <span class=c1>// 等价于 var m map[string]interface{}
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>MyPrint</span><span class=p>(</span><span class=nx>value</span> <span class=nx>any</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果你高兴得话，项目迁移到1.18之后可以使用下面这行命令直接把整个项目中的空接口全都替换成 any。当然因为并不强制，所以到底是用 <code>interface{}</code> 还是 <code>any</code> 全看自己喜好</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>gofmt</span> <span class=o>-</span><span class=nx>w</span> <span class=o>-</span><span class=nx>r</span> <span class=err>&#39;</span><span class=kd>interface</span><span class=p>{}</span> <span class=o>-</span><span class=p>&gt;</span> <span class=nx>any</span><span class=err>&#39;</span> <span class=p>.</span><span class=o>/...</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>💡 Go语言项目中就曾经有人提出过把Go语言中所有 interface{ }替换成 any 的 <a href="https://link.segmentfault.com/?enc=cZnyouuEN1aE6w0%2BYCDKpQ%3D%3D.w1hhEOZRawAiF5HRaYFmFrRkhaWouSPIq%2FPsXcKsDS5wyPGzXvbEis8%2B%2FRJz%2FrVw">issue</a>，然后因为影响范围过大过而且影响因素不确定，理所当然被驳回了</p></blockquote><h4 id=626-comparable可比较-和-可排序ordered>6.2.6 comparable(可比较) 和 可排序(ordered)</h4><p>对于一些数据类型，我们需要在类型约束中限制只能接受可用 <code>!=</code> 和 <code>==</code> 对比的类型，如map：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 错误。因为 map 中键的类型必须是可进行 != 和 == 比较的类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>MyMap</span><span class=p>[</span><span class=nx>KEY</span> <span class=nx>any</span><span class=p>,</span> <span class=nx>VALUE</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>map</span><span class=p>[</span><span class=nx>KEY</span><span class=p>]</span><span class=nx>VALUE</span> 
</span></span></code></pre></td></tr></table></div></div><p>所以Go直接内置了一个叫 <code>comparable</code> 的接口，它代表了所有可用 <code>!=</code> 以及 <code>==</code> 对比的类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyMap</span><span class=p>[</span><span class=nx>KEY</span> <span class=nx>comparable</span><span class=p>,</span> <span class=nx>VALUE</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>map</span><span class=p>[</span><span class=nx>KEY</span><span class=p>]</span><span class=nx>VALUE</span> <span class=c1>// 正确
</span></span></span></code></pre></td></tr></table></div></div><p><code>comparable</code> 比较容易引起误解的一点是很多人容易把他与可排序搞混淆。可比较指的是 可以执行 <code>!=</code> <code>==</code> 操作的类型，并没确保这个类型可以执行大小比较（ <code>>,&lt;,&lt;=,>=</code> ）。如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OhMyStruct</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>OhMyStruct</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>==</span> <span class=nx>b</span> <span class=c1>// 正确。结构体可使用 == 进行比较
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=o>!=</span> <span class=nx>b</span> <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>&gt;</span> <span class=nx>b</span> <span class=c1>// 错误。结构体不可比大小
</span></span></span></code></pre></td></tr></table></div></div><p>而可进行大小比较的类型被称为 <code>Orderd</code> 。目前Go语言并没有像 <code>comparable</code> 这样直接内置对应的关键词，所以想要的话需要自己来定义相关接口，比如我们可以参考Go官方包<code>golang.org/x/exp/constraints</code> 如何定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Ordered</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Integer</span> <span class=p>|</span> <span class=nx>Float</span> <span class=p>|</span> <span class=err>~</span><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Integer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Signed</span> <span class=p>|</span> <span class=nx>Unsigned</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Signed</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Unsigned</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint64</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uintptr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Float</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>float32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>💡 这里虽然可以直接使用官方包 <a href="https://link.segmentfault.com/?enc=HkB17Af1zfSpT4v8hJVpug%3D%3D.fpEYq9aLYa6XN8fW9Pzkryylc9ey%2FU%2BMHI0hcV8Y0JHGt38PX9do4UOrono7oieH"><code>golang.org/x/exp/constraints</code></a> ，但因为这个包属于实验性质的 <code>x</code> 包，今后可能会发生非常大变动，所以并不推荐直接使用</p><h3 id=63-接口两种类型>6.3 接口两种类型</h3><p>我们接下来再观察一个例子，这个例子是阐述接口类型集概念最好的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ReadWriter</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>string</span> <span class=p>|</span> <span class=p>|</span> <span class=err>~</span><span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>最开始看到这一例子你一定有点懵不太理解它代表的意思，但是没关系，我们用类型集的概念就能比较轻松理解这个接口的意思：</p><blockquote><p>接口类型 ReadWriter 代表了一个类型集合，所有以 string 或 []byte 为底层类型，并且含有 Read() Write() 这两个方法的类型都在 ReadWriter 代表的类型集当中</p></blockquote><p>如下面代码中，StringReadWriter 属于接口 ReadWriter 代表的类型集中，而因为 BytesReadWriter 的底层类型是 []byte ，所以它不属于 ReadWriter</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 类型 StringReadWriter 实现了接口 Readwriter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>StringReadWriter</span> <span class=kt>string</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>StringReadWriter</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>StringReadWriter</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//  类型BytesReadWriter 没有实现接口 Readwriter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>BytesReadWriter</span> <span class=p>[]</span><span class=kt>byte</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>BytesReadWriter</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>BytesReadWriter</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>你一定会说，啊等等，这接口也变得太复杂了把，那我定义一个 <code>ReadWriter</code> 接口，然后赋值的时候不光要考虑到方法的实现，还必须考虑到具体底层类型？心智负担也太大了吧。是的，为了解决这个问题也为了保持Go语言的兼容性，Go1.18开始将接口分为了两种类型</p><ul><li><strong>基本接口(Basic interface)</strong></li><li><strong>一般接口(General interface)</strong></li></ul><h4 id=631-基本接口basic-interface>6.3.1 基本接口(Basic interface)</h4><p>接口定义中如果只有方法的话，那么这种接口被称为<strong>基本接口(Basic interface)</strong>。这种写法就是Go1.18之前接口，其用法也基本和Go1.18之前保持一致。基本接口可以用于如下几个地方：</p><ul><li><p>最常用的，定义接口变量</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyError</span> <span class=kd>interface</span> <span class=p>{</span> <span class=c1>// 接口中只有方法，所以是基本接口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Error</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>err</span> <span class=nx>MyError</span> <span class=p>=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;hello world&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>基本接口因为也代表了一个类型集，所以可用在类型约束中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MySlice</span><span class=p>[</span><span class=nx>T</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span> <span class=p>|</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>]</span>  <span class=p>[]</span><span class=nx>Slice</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=632-一般接口general-interface>6.3.2 一般接口(General interface)</h4><p>如果接口内不光只有方法，还有类型的话，这种接口被称为 <strong>一般接口(General interface)</strong> ，如下例子都是一般接口：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Uint</span> <span class=kd>interface</span> <span class=p>{</span> <span class=c1>// 接口 Uint 带类型所以是一般接口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ReadWriter</span> <span class=kd>interface</span> <span class=p>{</span>  <span class=c1>// 接口带方法也带类型，所以是一般接口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=err>~</span><span class=kt>string</span> <span class=p>|</span> <span class=p>|</span> <span class=err>~</span><span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>一般接口不能用于变量定义和赋值，只能用于泛型的类型约束中</strong>。所以以下的用法是错误的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Uint</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>uintInf</span> <span class=nx>Uint</span> <span class=c1>// 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义
</span></span></span></code></pre></td></tr></table></div></div><p>这一限制保证了一般接口的使用被限定在了泛型之中，不会影响到Go1.18之前的代码，同时也极大减少了书写代码时的心智负担</p><h3 id=64-泛型接口>6.4 泛型接口</h3><p>接口也可以使用类型形参，观察下面这两个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>DataProcessor</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Process</span><span class=p>(</span><span class=nx>oriData</span> <span class=nx>T</span><span class=p>)</span> <span class=p>(</span><span class=nx>newData</span> <span class=nx>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Save</span><span class=p>(</span><span class=nx>data</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>DataProcessor2</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kd>struct</span><span class=p>{</span> <span class=nx>Data</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>Process</span><span class=p>(</span><span class=nx>data</span> <span class=nx>T</span><span class=p>)</span> <span class=p>(</span><span class=nx>newData</span> <span class=nx>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Save</span><span class=p>(</span><span class=nx>data</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>因为引入了类型形参，所以这两个接口是泛型类型(<strong>带类型形参的类型是泛型类型</strong>)，我们可以称之为泛型接口。<strong>而泛型类型要使用的话必须传入类型实参实例化才有意义</strong>。所以我们来尝试实例化一下这两个接口。因为 <code>T</code> 的类型约束是 any，所以我们可以随便挑一个类型来当实参(比如string)：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>DataProcessor</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 实例化之后的接口定义相当于如下所示：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>DataProcessor</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Process</span><span class=p>(</span><span class=nx>oriData</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>newData</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Save</span><span class=p>(</span><span class=nx>data</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>经过实例化之后就好理解了， <code>DataProcessor[string]</code> 因为只有方法，所以它实际上就是个 <strong>基本接口(Basic interface)</strong>，这个接口包含两个能处理string类型的方法。只要像下面这样实现了这两个能处理string类型的方法才算实现了这个接口：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>CSVProcessor</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=nx>CSVProcessor</span><span class=p>)</span> <span class=nf>Process</span><span class=p>(</span><span class=nx>oriData</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>newData</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=nx>CSVProcessor</span><span class=p>)</span> <span class=nf>Save</span><span class=p>(</span><span class=nx>oriData</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 正确。CSVProcessor实现了接口 DataProcessor[string]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>processor</span> <span class=nx>DataProcessor</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> <span class=p>=</span> <span class=nx>CSVProcessor</span><span class=p>{}</span>  
</span></span><span class=line><span class=cl><span class=nx>processor</span><span class=p>.</span><span class=nf>Process</span><span class=p>(</span><span class=s>&#34;name,age\nbob,12\njack,30&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>processor</span><span class=p>.</span><span class=nf>Save</span><span class=p>(</span><span class=s>&#34;name,age\nbob,13\njack,31&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 错误。CSVProcessor没有实现接口 DataProcessor[int]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>processor2</span> <span class=nx>DataProcessor</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=p>=</span> <span class=nx>CSVProcessor</span><span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><p>再用同样的方法实例化 <code>DataProcessor2[T]</code> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>DataProcessor2</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>DataProcessor2</span><span class=p>[</span><span class=nx>T</span> <span class=kt>string</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kd>struct</span><span class=p>{</span> <span class=nx>Data</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>Process</span><span class=p>(</span><span class=nx>data</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>newData</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Save</span><span class=p>(</span><span class=nx>data</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>DataProcessor2[string]</code> 因为带有类型并集所以它是 <strong>一般接口(General interface)</strong>，所以实例化之后的这个接口代表的意思是：</p><ol><li>只有实现了 <code>Process(string) string</code> 和 <code>Save(string) error</code> 这两个方法，并且以 <code>int</code> 或 <code>struct{ Data interface{} }</code> 为底层类型的类型才算实现了这个接口</li><li>一般接口不能用于变量定义只能用于类型约束，所以接口 <code>DataProcessor2[string]</code> 只是定义了一个用于类型约束的类型集</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// XMLProcessor 未实现 DataProcessor2[string]，因为它的底层类型是 []byte
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>XMLProcessor</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=nx>XMLProcessor</span><span class=p>)</span> <span class=nf>Process</span><span class=p>(</span><span class=nx>oriData</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>newData</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=nx>XMLProcessor</span><span class=p>)</span> <span class=nf>Save</span><span class=p>(</span><span class=nx>oriData</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// JsonProcessor 实现了接口 DataProcessor2[string]，因为它底层类型是 struct{ Data interface{} }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>JsonProcessor</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=nx>JsonProcessor</span><span class=p>)</span> <span class=nf>Process</span><span class=p>(</span><span class=nx>oriData</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>newData</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=nx>JsonProcessor</span><span class=p>)</span> <span class=nf>Save</span><span class=p>(</span><span class=nx>oriData</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 错误。虽然JsonProcessor实现了DataProcessor2[string]接口，但DataProcessor2[string]是一般接口不能用于创建变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>processor</span> <span class=nx>DataProcessor2</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> <span class=p>=</span> <span class=nx>JsonProcessor</span><span class=p>{}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 正确，实例化之后的 DataProcessor2[string] 可用于泛型的类型约束
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>ProcessorList</span><span class=p>[</span><span class=nx>T</span> <span class=nx>DataProcessor2</span><span class=p>[</span><span class=kt>string</span><span class=p>]]</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 正确，接口可以并入其他接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>StringProcessor</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>DataProcessor2</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>PrintString</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 错误，带方法的一般接口不能作为类型并集的成员(参考
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>StringProcessor</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>DataProcessor2</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> <span class=p>|</span> <span class=nx>DataProcessor2</span><span class=p>[[]</span><span class=kt>byte</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>PrintString</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=65-接口定义的种种限制规则>6.5 接口定义的种种限制规则</h3><p>Go1.18从开始，在定义类型集(接口)的时候增加了非常多十分琐碎的限制规则，因为找不到好的地方介绍，所以在这里统一介绍下：</p><ol><li><p>用 <code>|</code> 连接多个类型的时候，类型之间不能有相交的部分(即必须是不交集合):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyInt</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 错误，MyInt的底层类型是int,和 ~int 有相交的部分
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>_</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=nx>MyInt</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>但是相交的类型中有接口的话，则不受这一限制：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyInt</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>_</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=kd>interface</span><span class=p>{</span> <span class=nx>MyInt</span> <span class=p>}</span>  <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>类型的并集中不能有类型形参</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyInf</span><span class=p>[</span><span class=nx>T</span> <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>string</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>float32</span> <span class=p>|</span> <span class=nx>T</span>  <span class=c1>// 错误。T是类型形参
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyInf2</span><span class=p>[</span><span class=nx>T</span> <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>string</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>T</span>  <span class=c1>// 错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>接口不能直接间接地并入自己（即便是通过类型集也不行）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Bad</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Bad</span> <span class=c1>// 错误，接口不能直接并入自己
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Bad2</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Bad1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Bad1</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Bad2</span> <span class=c1>// 错误，接口Bad1通过Bad2间接并入了自己
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Bad3</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>string</span> <span class=p>|</span> <span class=nx>Bad3</span> <span class=c1>// 错误，通过类型集合类并入了自己
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>类型并集大于一个类型的时候，不能直接或间接包含预定义的 <code>comparable</code> 接口，也不能直接或间接包含有带方法的接口</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>type</span> <span class=nx>OK</span> <span class=kr>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>comparable</span> <span class=c1>// 正确。只有一个类型的时候可以使用 comparable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>type</span> <span class=nx>Bad1</span> <span class=kr>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>[]</span><span class=kr>int</span> <span class=o>|</span> <span class=nx>comparable</span> <span class=c1>// 错误，类型并集不能直接并入 comparable 接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>type</span> <span class=nx>CmpInf</span> <span class=kr>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>comparable</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>type</span> <span class=nx>Bad2</span> <span class=kr>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>chan</span> <span class=kr>int</span> <span class=o>|</span> <span class=nx>CmpInf</span>  <span class=c1>// 错误，类型并集通过 CmpInf 间接并入了comparable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>type</span> <span class=nx>Bad3</span> <span class=kr>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>chan</span> <span class=kr>int</span> <span class=o>|</span> <span class=kr>interface</span><span class=p>{</span><span class=nx>comparable</span><span class=p>}</span>  <span class=c1>// 理所当然这样也是不行的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>type</span> <span class=nx>InfWithMethod</span> <span class=kr>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=nx>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>Hello</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>type</span> <span class=nx>Bad4</span> <span class=kr>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>int</span> <span class=o>|</span> <span class=nx>InfWithMethod</span> <span class=c1>// 错误，类型并集并入了带方法的接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>type</span> <span class=nx>OK2</span> <span class=kr>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>InfWithMethod</span> <span class=c1>// 正确，这里是直接内嵌了 InfWithMethod 接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>type</span> <span class=nx>Bad5</span> <span class=kr>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=kr>int</span> <span class=o>|</span> <span class=nx>Bad5</span>  <span class=c1>// 错误，类型并集中间接并入带方法的接口也是也不行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>带方法的接口(无论是基本接口还是一般接口)，都不能写入接口的类型并集中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>_</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>string</span> <span class=p>|</span> <span class=kt>error</span> <span class=c1>// 错误，error带方法(是一般接口)，不能写入并集中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>DataProcessor</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>~</span><span class=kt>string</span> <span class=p>|</span> <span class=err>~</span><span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>Process</span><span class=p>(</span><span class=nx>data</span> <span class=nx>T</span><span class=p>)</span> <span class=p>(</span><span class=nx>newData</span> <span class=nx>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Save</span><span class=p>(</span><span class=nx>data</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 错误，实例化之后的 DataProcessor[string] 是带方法的一般接口，不能写入类型并集
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>_</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>string</span> <span class=p>|</span> <span class=nx>DataProcessor</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h2 id=7-总结>7. 总结</h2><p>至此，终于是从头到位把Go1.18的泛型给介绍完毕了。因为Go这次引入泛型带入了挺大的复杂度，也增加了挺多比较零散琐碎的规则限制。所以写这篇文章断断续续花了我差不多一星期时间。泛型虽然很受期待，但实际上推荐的使用场景也并没有那么广泛，对于泛型的使用，我们应该遵守下面的规则：</p><blockquote><p>泛型并不取代Go1.18之前用接口实现的动态类型，在下面情景的时候非常适合使用泛型：当你需要针对不同类型书写同样逻辑的代码的时候，使用泛型来简化代码是最好的(如你想写个队列</p></blockquote><h2 id=参考资料>参考资料</h2><ul><li><a href="https://link.segmentfault.com/?enc=AKDrwhUrsa1%2FVfzSAppOOQ%3D%3D.AZ6H8NCc5Yd9VJQAwjPhEk1Wuw%2FAdv4EWOMnVxKj0ko%3D">The Go Programming Language Specification - The Go Programming Language</a></li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>wanfeng</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2022-04-14</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=https://studyboot.com/tags/go/>go</a>
<a href=https://studyboot.com/tags/golang/>golang</a>
<a href=https://studyboot.com/tags/templates/>templates</a>
<a href=https://studyboot.com/tags/themes/>themes</a>
<a href=https://studyboot.com/tags/development/>development</a></div><nav class=post-nav><a class=prev href=/post/jane-theme-preview/><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg></i><span class="prev-text nav-default">Jane 主题预览</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/math-preview/><span class="next-text nav-default">Math Preview</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=icon-links><a href=https://wanfengedge.github.io rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg></a><a href=https://studyboot.com/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a></span>
<span class=copyright-year>&copy;
2022
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg></i></span><span class=author>晚风</span></span></div></footer><div class=back-to-top id=back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>